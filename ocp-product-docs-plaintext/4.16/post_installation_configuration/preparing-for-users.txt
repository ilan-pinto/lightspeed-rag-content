# Preparing for users


After installing Red Hat OpenShift Container Platform, you can further expand and customize your
cluster to your requirements, including taking steps to prepare for users.

# Understanding identity provider configuration

The Red Hat OpenShift Container Platform control plane includes a built-in OAuth server. Developers and
administrators obtain OAuth access tokens to authenticate themselves to the API.

As an administrator, you can configure OAuth to specify an identity provider
after you install your cluster.

## About identity providers in Red Hat OpenShift Container Platform

By default, only a kubeadmin user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.


[NOTE]
----
Red Hat OpenShift Container Platform user names containing /, :, and % are not supported.
----

## Supported identity providers

You can configure the following types of identity providers:



After you define an identity provider, you can
use
RBAC to define and apply permissions.

## Identity provider parameters

The following parameters are common to all identity providers:




[NOTE]
----
When adding or changing identity providers, you can map identities from the new
provider to existing users by setting the mappingMethod parameter to
add.
----

## Sample identity provider CR

The following custom resource (CR) shows the parameters and default
values that you use to configure an identity provider. This example
uses the htpasswd identity provider.


```yaml
apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: my_identity_provider 1
    mappingMethod: claim 2
    type: HTPasswd
    htpasswd:
      fileData:
        name: htpass-secret 3
```


This provider name is prefixed to provider user names to form an
identity name.
Controls how mappings are established between this provider's
identities and User objects.
An existing secret containing a file generated using
htpasswd.

# Using RBAC to define and apply permissions

Understand and apply role-based access control.

## RBAC overview

Role-based access control (RBAC) objects determine whether a user is allowed to
perform a given action within a project.

can use the cluster roles and bindings to control who has various access levels to the Red Hat OpenShift Container Platform platform itself and all projects.

Developers can use local roles and bindings to control who has access
to their projects. Note that authorization is a separate step from
authentication, which is more about determining the identity of who is taking the action.

Authorization is managed using:



Be mindful of the difference between local and cluster bindings. For example,
if you bind the cluster-admin role to a user by using a local role binding,
it might appear that this user has the privileges of a cluster administrator.
This is not the case. Binding the cluster-admin to a user in a project
grants super administrator privileges for only that project to the user. That user has the permissions of the cluster role admin, plus a few additional permissions like the ability to edit rate limits, for that project. This binding can be confusing via the web console UI, which does not list cluster role bindings that are bound to true cluster administrators. However, it does list local role bindings that you can use to locally bind cluster-admin.

The relationships between cluster roles, local roles, cluster role bindings,
local role bindings, users, groups and service accounts are illustrated below.

![Red Hat OpenShift Container Platform RBAC]


[WARNING]
----
The get pods/exec, get pods/*, and get * rules grant execution privileges when they are applied to a role. Apply the principle of least privilege and assign only the minimal RBAC rights required for users and agents. For more information, see RBAC rules allow execution privileges.
----

### Evaluating authorization

Red Hat OpenShift Container Platform evaluates authorization by using:

Identity:: The user name and list of groups that the user belongs to.
Action:: The action you perform. In most cases, this consists of:
* Project: The project you access. A project is a Kubernetes namespace with
additional annotations that allows a community of users to organize and manage
their content in isolation from other communities.
* Verb : The action itself:  get, list, create, update, delete, deletecollection, or watch.
* Resource name: The API endpoint that you access.
Bindings:: The full list of bindings, the associations between users or groups
with a role.

Red Hat OpenShift Container Platform evaluates authorization by using the following steps:

1. The identity and the project-scoped action is used to find all bindings that
apply to the user or their groups.
2. Bindings are used to locate all the roles that apply.
3. Roles are used to find all the rules that apply.
4. The action is checked against each rule to find a match.
5. If no matching rule is found, the action is then denied by default.

including a matrix of the verbs and resources each are associated with.

## Projects and namespaces

A Kubernetes namespace provides a mechanism to scope resources in a cluster.
The
Kubernetes documentation
has more information on namespaces.

Namespaces provide a unique scope for:

* Named resources to avoid basic naming collisions.
* Delegated management authority to trusted users.
* The ability to limit community resource consumption.

Most objects in the system are scoped by namespace, but some are
excepted and have no namespace, including nodes and users.

A project is a Kubernetes namespace with additional annotations and is the central vehicle
by which access to resources for regular users is managed.
A project allows a community of users to organize and manage their content in
isolation from other communities. Users must be given access to projects by administrators,
or if allowed to create projects, automatically have access to their own projects.

Projects can have a separate name, displayName, and description.

* The mandatory name is a unique identifier for the project and is most visible when using the CLI tools or API. The maximum name length is 63 characters.
* The optional displayName is how the project is displayed in the web console (defaults to name).
* The optional description can be a more detailed description of the project and is also visible in the web console.

Each project scopes its own set of:



Cluster administrators
can create projects and delegate administrative rights for the project to any member of the user community.
Cluster administrators
can also allow developers to create their own projects.

Developers and administrators can interact with projects by using the CLI or the
web console.

## Default projects

Red Hat OpenShift Container Platform comes with a number of default projects, and projects
starting with openshift- are the most essential to users.
These projects host master components that run as pods and other infrastructure
components. The pods created in these namespaces that have a
critical pod annotation
are considered critical, and the have guaranteed admission by kubelet.
Pods created for master components in these namespaces are already marked as
critical.


[IMPORTANT]
----
Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.
The following default projects are considered highly privileged: default, kube-public, kube-system, openshift, openshift-infra, openshift-node, and other system-created projects that have the openshift.io/run-level label set to 0 or 1. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.
----

## Viewing cluster roles and bindings

You can use the oc CLI to view cluster roles and bindings by using the
oc describe command.

* Install the oc CLI.
* Obtain permission to view the cluster roles and bindings.

1. To view the cluster roles and their associated rule sets:
2. To view the current set of cluster role bindings, which shows the users and
groups that are bound to various roles:

## Viewing local roles and bindings

You can use the oc CLI to view local roles and bindings by using the
oc describe command.

* Install the oc CLI.
* Obtain permission to view the local roles and bindings:
* Users with the admin default cluster role bound locally can view and manage
roles and bindings in that project.

1. To view the current set of local role bindings, which show the users and groups
that are bound to various roles for the current project:

```terminal
$ oc describe rolebinding.rbac
```

2. To view the local role bindings for a different project, add the -n flag
to the command:

```terminal
$ oc describe rolebinding.rbac -n joe-project
```

Example output

```terminal
Name:         admin
Labels:       <none>
Annotations:  <none>
Role:
  Kind:  ClusterRole
  Name:  admin
Subjects:
  Kind  Name        Namespace
  ----  ----        ---------
  User  kube:admin


Name:         system:deployers
Labels:       <none>
Annotations:  openshift.io/description:
                Allows deploymentconfigs in this namespace to rollout pods in
                this namespace.  It is auto-managed by a controller; remove
                subjects to disa...
Role:
  Kind:  ClusterRole
  Name:  system:deployer
Subjects:
  Kind            Name      Namespace
  ----            ----      ---------
  ServiceAccount  deployer  joe-project


Name:         system:image-builders
Labels:       <none>
Annotations:  openshift.io/description:
                Allows builds in this namespace to push images to this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-builder
Subjects:
  Kind            Name     Namespace
  ----            ----     ---------
  ServiceAccount  builder  joe-project


Name:         system:image-pullers
Labels:       <none>
Annotations:  openshift.io/description:
                Allows all pods in this namespace to pull images from this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-puller
Subjects:
  Kind   Name                                Namespace
  ----   ----                                ---------
  Group  system:serviceaccounts:joe-project
```


## Adding roles to users

You can use  the oc adm administrator CLI to manage the roles and bindings.

Binding, or adding, a role to users or groups gives the user or group the access
that is granted by the role. You can add and remove roles to and from users and
groups using oc adm policy commands.

You can bind any of the default cluster roles to local users or groups in your
project.

1. Add a role to a user in a specific project:

```terminal
$ oc adm policy add-role-to-user <role> <user> -n <project>
```


For example, you can add the admin role to the alice user in joe project
by running:

```terminal
$ oc adm policy add-role-to-user admin alice -n joe
```


[TIP]
----
You can alternatively apply the following YAML to add the role to the user:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: admin-0
  namespace: joe
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: alice
```

----
2. View the local role bindings and verify the addition in the output:

```terminal
$ oc describe rolebinding.rbac -n <project>
```


For example, to view the local role bindings for the joe project:

```terminal
$ oc describe rolebinding.rbac -n joe
```

Example output

```terminal
Name:         admin
Labels:       <none>
Annotations:  <none>
Role:
  Kind:  ClusterRole
  Name:  admin
Subjects:
  Kind  Name        Namespace
  ----  ----        ---------
  User  kube:admin


Name:         admin-0
Labels:       <none>
Annotations:  <none>
Role:
  Kind:  ClusterRole
  Name:  admin
Subjects:
  Kind  Name   Namespace
  ----  ----   ---------
  User  alice 1


Name:         system:deployers
Labels:       <none>
Annotations:  openshift.io/description:
                Allows deploymentconfigs in this namespace to rollout pods in
                this namespace.  It is auto-managed by a controller; remove
                subjects to disa...
Role:
  Kind:  ClusterRole
  Name:  system:deployer
Subjects:
  Kind            Name      Namespace
  ----            ----      ---------
  ServiceAccount  deployer  joe


Name:         system:image-builders
Labels:       <none>
Annotations:  openshift.io/description:
                Allows builds in this namespace to push images to this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-builder
Subjects:
  Kind            Name     Namespace
  ----            ----     ---------
  ServiceAccount  builder  joe


Name:         system:image-pullers
Labels:       <none>
Annotations:  openshift.io/description:
                Allows all pods in this namespace to pull images from this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-puller
Subjects:
  Kind   Name                                Namespace
  ----   ----                                ---------
  Group  system:serviceaccounts:joe
```

The alice user has been added to the admins RoleBinding.

## Local role binding commands

When you manage a user or group&#8217;s associated roles for local role bindings using the
following operations, a project may be specified with the -n flag. If it is
not specified, then the current project is used.

You can use the following commands for local RBAC management.



# The kubeadmin user

Red Hat OpenShift Container Platform creates a cluster administrator, kubeadmin, after the
installation process completes.

This user has the cluster-admin role automatically applied and is treated
as the root user for the cluster. The password is dynamically generated
and unique to your Red Hat OpenShift Container Platform environment. After installation
completes the password is provided in the installation program&#8217;s output.
For example:


```terminal
INFO Install complete!
INFO Run 'export KUBECONFIG=<your working directory>/auth/kubeconfig' to manage the cluster with 'oc', the OpenShift CLI.
INFO The cluster is ready when 'oc login -u kubeadmin -p <provided>' succeeds (wait a few minutes).
INFO Access the OpenShift web-console here: https://console-openshift-console.apps.demo1.openshift4-beta-abcorp.com
INFO Login to the console with user: kubeadmin, password: <provided>
```


## Removing the kubeadmin user

After you define an identity provider and create a new cluster-admin
user, you can remove the kubeadmin to improve cluster security.


[WARNING]
----
If you follow this procedure before another user is a cluster-admin,
then Red Hat OpenShift Container Platform must be reinstalled. It is not possible to undo
this command.
----

* You must have configured at least one identity provider.
* You must have added the cluster-admin role to a user.
* You must be logged in as an administrator.

* Remove the kubeadmin secrets:

```terminal
$ oc delete secrets kubeadmin -n kube-system
```


# Image configuration

Understand and configure image registry settings.

## Image controller configuration parameters

The image.config.openshift.io/cluster resource holds cluster-wide information about how to handle images. The canonical, and only valid name is cluster. Its spec offers the following configuration parameters.


[NOTE]
----
Parameters such as DisableScheduledImport, MaxImagesBulkImportedPerRepository, MaxScheduledImportsPerMinute, ScheduledImageImportMinimumIntervalSeconds, InternalRegistryHostname are not configurable.
----




[WARNING]
----
When the allowedRegistries parameter is defined, all registries, including registry.redhat.io and quay.io registries and the default OpenShift image registry, are blocked unless explicitly listed. When using the parameter, to prevent pod failure, add all registries including the registry.redhat.io and quay.io registries and the internalRegistryHostname to the allowedRegistries list, as they are required by payload images within your environment. For disconnected clusters, mirror registries should also be added.
----

The status field of the image.config.openshift.io/cluster resource holds observed values from the cluster.



## Configuring image registry settings

You can configure image registry settings by editing the image.config.openshift.io/cluster custom resource (CR).
When changes to the registry are applied to the image.config.openshift.io/cluster CR, the Machine Config Operator (MCO) performs the following sequential actions:

1. Cordons the node
2. Applies changes by restarting CRI-O
3. Uncordons the node

[NOTE]
----
The MCO does not restart nodes when it detects changes.
----

1. Edit the image.config.openshift.io/cluster custom resource:

```terminal
$ oc edit image.config.openshift.io/cluster
```


The following is an example image.config.openshift.io/cluster CR:

```yaml
apiVersion: config.openshift.io/v1
kind: Image 1
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 1
  name: cluster
  resourceVersion: "8302"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: e34555da-78a9-11e9-b92b-06d6c7da38dc
spec:
  allowedRegistriesForImport: 2
    - domainName: quay.io
      insecure: false
  additionalTrustedCA: 3
    name: myconfigmap
  registrySources: 4
    allowedRegistries:
    - example.com
    - quay.io
    - registry.redhat.io
    - image-registry.openshift-image-registry.svc:5000
    - reg1.io/myrepo/myapp:latest
    insecureRegistries:
    - insecure.com
status:
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000
```

Image: Holds cluster-wide information about how to handle images. The canonical, and only valid name is cluster.
allowedRegistriesForImport: Limits the container image registries from which normal users may import images. Set this list to the registries that you trust to contain valid images, and that you want applications to be able to import from. Users with permission to create images or ImageStreamMappings from the API are not affected by this policy. Typically only cluster administrators have the appropriate permissions.
additionalTrustedCA: A reference to a config map containing additional certificate authorities (CA) that are trusted during image stream import, pod image pull, openshift-image-registry pullthrough, and builds. The namespace for this config map is openshift-config. The format of the config map is to use the registry hostname as the key, and the PEM certificate as the value, for each additional registry CA to trust.
registrySources: Contains configuration that determines whether the container runtime allows or blocks individual registries when accessing images for builds and pods.  Either the allowedRegistries parameter or the blockedRegistries parameter can be set, but not both. You can also define whether or not to allow access to insecure registries or registries that allow registries that use image short names. This example uses the allowedRegistries parameter, which defines the registries that are allowed to be used. The insecure registry insecure.com is also allowed. The registrySources parameter does not contain configuration for the internal cluster registry.

[NOTE]
----
When the allowedRegistries parameter is defined, all registries, including the registry.redhat.io and quay.io registries and the default OpenShift image registry, are blocked unless explicitly listed. If you use the parameter, to prevent pod failure, you must add the registry.redhat.io and quay.io registries and the internalRegistryHostname to the allowedRegistries list, as they are required by payload images within your environment. Do not add the registry.redhat.io and quay.io registries to the blockedRegistries list.
When using the allowedRegistries, blockedRegistries, or insecureRegistries parameter, you can specify an individual repository within a registry. For example: reg1.io/myrepo/myapp:latest.
Insecure external registries should be avoided to reduce possible security risks.
----
2. To check that the changes are applied, list your nodes:

```terminal
$ oc get nodes
```

Example output

```terminal
NAME                                         STATUS                     ROLES                  AGE   VERSION
ip-10-0-137-182.us-east-2.compute.internal   Ready,SchedulingDisabled   worker                 65m   v1.29.4
ip-10-0-139-120.us-east-2.compute.internal   Ready,SchedulingDisabled   control-plane          74m   v1.29.4
ip-10-0-176-102.us-east-2.compute.internal   Ready                      control-plane          75m   v1.29.4
ip-10-0-188-96.us-east-2.compute.internal    Ready                      worker                 65m   v1.29.4
ip-10-0-200-59.us-east-2.compute.internal    Ready                      worker                 63m   v1.29.4
ip-10-0-223-123.us-east-2.compute.internal   Ready                      control-plane          73m   v1.29.4
```


For more information on the allowed, blocked, and insecure registry parameters, see Configuring image registry settings.

## Configuring additional trust stores for image registry access

The image.config.openshift.io/cluster custom resource can contain a reference to a config map that contains additional certificate authorities to be trusted during image registry access.

* The certificate authorities (CA) must be PEM-encoded.

You can create a config map in the openshift-config namespace and use its name in AdditionalTrustedCA in the image.config.openshift.io custom resource to provide additional CAs that should be trusted when contacting external registries.

The config map key is the hostname of a registry with the port for which this CA is to be trusted, and the PEM certificate content is the value, for each additional registry CA to trust.


```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-registry-ca
data:
  registry.example.com: |
    -----BEGIN CERTIFICATE-----
    ...
    -----END CERTIFICATE-----
  registry-with-port.example.com..5000: | 1
    -----BEGIN CERTIFICATE-----
    ...
    -----END CERTIFICATE-----
```


If the registry has the port, such as registry-with-port.example.com:5000, : should be replaced with &#8230;&#8203;

You can configure additional CAs with the following procedure.

* To configure an additional CA:

```terminal
$ oc create configmap registry-config --from-file=<external_registry_address>=ca.crt -n openshift-config
```


```terminal
$ oc edit image.config.openshift.io cluster
```


```yaml
spec:
  additionalTrustedCA:
    name: registry-config
```


# Understanding image registry repository mirroring

Setting up container registry repository mirroring enables you to perform the following tasks:

* Configure your Red Hat OpenShift Container Platform cluster to redirect requests to pull images from a repository on a source image registry and have it resolved by a repository on a mirrored image registry.
* Identify multiple mirrored repositories for each target repository, to make sure that if one mirror is down, another can be used.

Repository mirroring in Red Hat OpenShift Container Platform includes the following attributes:

* Image pulls are resilient to registry downtimes.
* Clusters in disconnected environments can pull images from critical locations, such as quay.io, and have registries behind a company firewall provide the requested images.
* A particular order of registries is tried when an image pull request is made, with the permanent registry typically being the last one tried.
* The mirror information you enter is added to the /etc/containers/registries.conf file on every node in the Red Hat OpenShift Container Platform cluster.
* When a node makes a request for an image from the source repository, it tries each mirrored repository in turn until it finds the requested content. If all mirrors fail, the cluster tries the source repository. If successful, the image is pulled to the node.

Setting up repository mirroring can be done in the following ways:

* At Red Hat OpenShift Container Platform installation:

By pulling container images needed by Red Hat OpenShift Container Platform and then bringing those images behind your company&#8217;s firewall, you can install Red Hat OpenShift Container Platform into a datacenter that is in a disconnected environment.
* After Red Hat OpenShift Container Platform installation:

If you did not configure mirroring during Red Hat OpenShift Container Platform installation, you can do so postinstallation by using any of the following custom resource (CR) objects:
* ImageDigestMirrorSet (IDMS). This object allows you to pull images from a mirrored registry by using digest specifications. The IDMS CR enables you to set a fall back policy that allows or stops continued attempts to pull from the source registry if the image pull fails.
* ImageTagMirrorSet (ITMS). This object allows you to pull images from a mirrored registry by using image tags. The ITMS CR enables you to set a fall back policy that allows or stops continued attempts to pull from the source registry if the image pull fails.
* ImageContentSourcePolicy (ICSP). This object allows you to pull images from a mirrored registry by using digest specifications. The ICSP CR always falls back to the source registry if the mirrors do not work.

[IMPORTANT]
----
Using an ImageContentSourcePolicy (ICSP) object to configure repository mirroring is a deprecated feature. Deprecated functionality is still included in Red Hat OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments. If you have existing YAML files that you used to create ImageContentSourcePolicy objects, you can use the oc adm migrate icsp command to convert those files to an ImageDigestMirrorSet YAML file. For more information, see "Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring" in the following section.
----

Each of these custom resource objects identify the following information:

* The source of the container image repository you want to mirror.
* A separate entry for each mirror repository you want to offer the content
requested from the source repository.

For new clusters, you can use IDMS, ITMS, and ICSP CRs objects as desired. However, using IDMS and ITMS is recommended.

If you upgraded a cluster, any existing ICSP objects remain stable, and both IDMS and ICSP objects are supported. Workloads using ICSP objects continue to function as expected. However, if you want to take advantage of the fallback policies introduced in the IDMS CRs, you can migrate current workloads to IDMS objects by using the oc adm migrate icsp command as shown in the Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring section that follows. Migrating to IDMS objects does not require a cluster reboot.


[NOTE]
----
If your cluster uses an ImageDigestMirrorSet, ImageTagMirrorSet, or ImageContentSourcePolicy object to configure repository mirroring, you can use only global pull secrets for mirrored registries. You cannot add a pull secret to a project.
----

## Configuring image registry repository mirroring

You can create postinstallation mirror configuration custom resources (CR) to redirect image pull requests from a source image registry to a mirrored image registry.

* Access to the cluster as a user with the cluster-admin role.

1. Configure mirrored repositories, by either:
* Setting up a mirrored repository with Red Hat Quay, as described in Red Hat Quay Repository Mirroring. Using Red Hat Quay allows you to copy images from one repository to another and also automatically sync those repositories repeatedly over time.
* Using a tool such as skopeo to copy images manually from the source repository to the mirrored repository.

For example, after installing the skopeo RPM package on a Red Hat Enterprise Linux (RHEL) 7 or RHEL 8 system, use the skopeo command as shown in this example:

```terminal
$ skopeo copy \
docker://registry.access.redhat.com/ubi9/ubi-minimal:latest@sha256:5cf... \
docker://example.io/example/ubi-minimal
```


In this example, you have a container image registry that is named example.io with an image repository named example to which you want to copy the ubi9/ubi-minimal image from registry.access.redhat.com. After you create the mirrored registry, you can configure your Red Hat OpenShift Container Platform cluster to redirect requests made of the source repository to the mirrored repository.
2. Log in to your Red Hat OpenShift Container Platform cluster.
3. Create a postinstallation mirror configuration CR, by using one of the following examples:
* Create an ImageDigestMirrorSet or ImageTagMirrorSet CR, as needed, replacing the source and mirrors with your own registry and repository pairs and images:

```yaml
apiVersion: config.openshift.io/v1 1
kind: ImageDigestMirrorSet 2
metadata:
  name: ubi9repo
spec:
  imageDigestMirrors: 3
  - mirrors:
    - example.io/example/ubi-minimal 4
    - example.com/example/ubi-minimal 5
    source: registry.access.redhat.com/ubi9/ubi-minimal 6
    mirrorSourcePolicy: AllowContactingSource 7
  - mirrors:
    - mirror.example.com/redhat
    source: registry.example.com/redhat 8
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.com
    source: registry.example.com 9
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net/image
    source: registry.example.com/example/myimage 10
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net
    source: registry.example.com/example 11
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net/registry-example-com
    source: registry.example.com 12
    mirrorSourcePolicy: AllowContactingSource
```

Indicates the API to use with this CR. This must be config.openshift.io/v1.
Indicates the kind of object according to the pull type:
* ImageDigestMirrorSet: Pulls a digest reference image.
* ImageTagMirrorSet: Pulls a tag reference image.
Indicates the type of image pull method, either:
* imageDigestMirrors: Use for an ImageDigestMirrorSet CR.
* imageTagMirrors: Use for an ImageTagMirrorSet CR.
Indicates the name of the mirrored image registry and repository.
Optional: Indicates a secondary mirror repository for each target repository. If one mirror is down, the target repository can use another mirror.
Indicates the registry and repository source, which is the repository that is referred to in image pull specifications.
Optional: Indicates the fallback policy if the image pull fails:
* AllowContactingSource: Allows continued attempts to pull the image from the source repository. This is the default.
* NeverContactSource: Prevents continued attempts to pull the image from the source repository.
Optional: Indicates a namespace inside a registry, which allows you to use any image in that namespace. If you use a registry domain as a source, the object is applied to all repositories from the registry.
Optional: Indicates a registry, which allows you to use any image in that registry. If you specify a registry name, the object is applied to all repositories from a source registry to a mirror registry.
Pulls the image registry.example.com/example/myimage@sha256:&#8230;&#8203; from the mirror mirror.example.net/image@sha256:&#8230;&#8203;
Pulls the image registry.example.com/example/image@sha256:&#8230;&#8203; in the source registry namespace from the mirror mirror.example.net/image@sha256:&#8230;&#8203;.
Pulls the image registry.example.com/myimage@sha256 from the mirror registry example.net/registry-example-com/myimage@sha256:&#8230;&#8203;.
* Create an ImageContentSourcePolicy custom resource, replacing the source and mirrors with your own registry and repository pairs and images:

```yaml
apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  name: mirror-ocp
spec:
  repositoryDigestMirrors:
  - mirrors:
    - mirror.registry.com:443/ocp/release 1
    source: quay.io/openshift-release-dev/ocp-release 2
  - mirrors:
    - mirror.registry.com:443/ocp/release
    source: quay.io/openshift-release-dev/ocp-v4.0-art-dev
```

Specifies the name of the mirror image registry and repository.
Specifies the online registry and repository containing the content that is mirrored.
4. Create the new object:

```terminal
$ oc create -f registryrepomirror.yaml
```


After the object is created, the Machine Config Operator (MCO) drains the nodes for ImageTagMirrorSet objects only. The MCO does not drain the nodes for ImageDigestMirrorSet and ImageContentSourcePolicy objects.
5. To check that the mirrored configuration settings are applied, do the following on one of the nodes.
1. List your nodes:

```terminal
$ oc get node
```

Example output

```terminal
NAME                           STATUS                     ROLES    AGE  VERSION
ip-10-0-137-44.ec2.internal    Ready                      worker   7m   v1.29.4
ip-10-0-138-148.ec2.internal   Ready                      master   11m  v1.29.4
ip-10-0-139-122.ec2.internal   Ready                      master   11m  v1.29.4
ip-10-0-147-35.ec2.internal    Ready                      worker   7m   v1.29.4
ip-10-0-153-12.ec2.internal    Ready                      worker   7m   v1.29.4
ip-10-0-154-10.ec2.internal    Ready                      master   11m  v1.29.4
```

2. Start the debugging process to access the node:

```terminal
$ oc debug node/ip-10-0-147-35.ec2.internal
```

Example output

```terminal
Starting pod/ip-10-0-147-35ec2internal-debug ...
To use host binaries, run `chroot /host`
```

3. Change your root directory to /host:

```terminal
sh-4.2# chroot /host
```

4. Check the /etc/containers/registries.conf file to make sure the changes were made:

```terminal
sh-4.2# cat /etc/containers/registries.conf
```


The following output represents a registries.conf file where postinstallation mirror configuration CRs were applied. The final two entries are marked digest-only and tag-only respectively.
Example output

```terminal
unqualified-search-registries = ["registry.access.redhat.com", "docker.io"]
short-name-mode = ""

[[registry]]
  prefix = ""
  location = "registry.access.redhat.com/ubi9/ubi-minimal" 1

  [[registry.mirror]]
    location = "example.io/example/ubi-minimal" 2
    pull-from-mirror = "digest-only" 3

  [[registry.mirror]]
    location = "example.com/example/ubi-minimal"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com"

  [[registry.mirror]]
    location = "mirror.example.net/registry-example-com"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/example"

  [[registry.mirror]]
    location = "mirror.example.net"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/example/myimage"

  [[registry.mirror]]
    location = "mirror.example.net/image"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com"

  [[registry.mirror]]
    location = "mirror.example.com"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/redhat"

  [[registry.mirror]]
    location = "mirror.example.com/redhat"
    pull-from-mirror = "digest-only"
[[registry]]
  prefix = ""
  location = "registry.access.redhat.com/ubi9/ubi-minimal"
  blocked = true 4

  [[registry.mirror]]
    location = "example.io/example/ubi-minimal-tag"
    pull-from-mirror = "tag-only" 5
```

Indicates the repository that is referred to in a pull spec.
Indicates the mirror for that repository.
Indicates that the image pull from the mirror is a digest reference image.
Indicates that the NeverContactSource parameter is set for this repository.
Indicates that the image pull from the mirror is a tag reference image.
5. Pull an image to the node from the source and check if it is resolved by the mirror.

```terminal
sh-4.2# podman pull --log-level=debug registry.access.redhat.com/ubi9/ubi-minimal@sha256:5cf...
```


If the repository mirroring procedure does not work as described, use the following information about how repository mirroring works to help troubleshoot the problem.

* The first working mirror is used to supply the pulled image.
* The main registry is only used if no other mirror works.
* From the system context, the Insecure flags are used as fallback.
* The format of the /etc/containers/registries.conf file has changed recently. It is now version 2 and in TOML format.

## Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring

Using an ImageContentSourcePolicy (ICSP) object to configure repository mirroring is a deprecated feature. This functionality is still included in Red Hat OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.

ICSP objects are being replaced by ImageDigestMirrorSet and ImageTagMirrorSet objects to configure repository mirroring. If you have existing YAML files that you used to create ImageContentSourcePolicy objects, you can use the oc adm migrate icsp command to convert those files to an ImageDigestMirrorSet YAML file. The command updates the API to the current version, changes the kind value to ImageDigestMirrorSet, and changes spec.repositoryDigestMirrors to spec.imageDigestMirrors. The rest of the file is not changed.

Because the migration does not change the registries.conf file, the cluster does not need to reboot.

For more information about ImageDigestMirrorSet or ImageTagMirrorSet objects, see "Configuring image registry repository mirroring" in the previous section.

* Access to the cluster as a user with the cluster-admin role.
* Ensure that you have ImageContentSourcePolicy objects on your cluster.

1. Use the following command to convert one or more ImageContentSourcePolicy YAML files to an ImageDigestMirrorSet YAML file:

```terminal
$ oc adm migrate icsp <file_name>.yaml <file_name>.yaml <file_name>.yaml --dest-dir <path_to_the_directory>
```

where:
<file_name>:: Specifies the name of the source ImageContentSourcePolicy YAML. You can list multiple file names.
--dest-dir:: Optional: Specifies a directory for the output ImageDigestMirrorSet YAML. If unset, the file is written to the current directory.

For example, the following command converts the icsp.yaml and icsp-2.yaml file and saves the new YAML files to the idms-files directory.

```terminal
$ oc adm migrate icsp icsp.yaml icsp-2.yaml --dest-dir idms-files
```

Example output

```terminal
wrote ImageDigestMirrorSet to idms-files/imagedigestmirrorset_ubi8repo.5911620242173376087.yaml
wrote ImageDigestMirrorSet to idms-files/imagedigestmirrorset_ubi9repo.6456931852378115011.yaml
```

2. Create the CR object by running the following command:

```terminal
$ oc create -f <path_to_the_directory>/<file-name>.yaml
```

where:
<path_to_the_directory>:: Specifies the path to the directory, if you used the --dest-dir flag.
<file_name>:: Specifies the name of the ImageDigestMirrorSet YAML.
3. Remove the ICSP objects after the IDMS objects are rolled out.

# Populating OperatorHub from mirrored Operator catalogs

If you mirrored Operator catalogs for use with disconnected clusters, you can populate OperatorHub with the Operators from your mirrored catalogs. You can use the generated manifests from the mirroring process to create the required ImageContentSourcePolicy and CatalogSource objects.

## Prerequisites

* Mirroring Operator catalogs for use with disconnected clusters

## Creating the ImageContentSourcePolicy object

After mirroring Operator catalog content to your mirror registry, create the required ImageContentSourcePolicy (ICSP) object. The ICSP object configures nodes to translate between the image references stored in Operator manifests and the mirrored registry.

* On a host with access to the disconnected cluster, create the ICSP by running the following command to specify the imageContentSourcePolicy.yaml file in your manifests directory:

```terminal
$ oc create -f <path/to/manifests/dir>/imageContentSourcePolicy.yaml
```


where <path/to/manifests/dir> is the path to the manifests directory for your mirrored content.

You can now create a CatalogSource object to reference your mirrored index image and Operator content.

## Adding a catalog source to a cluster

Adding a catalog source to an Red Hat OpenShift Container Platform cluster enables the discovery and installation of Operators for users.
Cluster administrators
can create a CatalogSource object that references an index image. OperatorHub uses catalog sources to populate the user interface.


[TIP]
----
Alternatively, you can use the web console to manage catalog sources. From the Administration -> Cluster Settings -> Configuration -> OperatorHub page, click the Sources tab, where you can create, update, delete, disable, and enable individual sources.
----

* You built and pushed an index image to a registry.
* You have access to the cluster as a user with the cluster-admin role.

1. Create a CatalogSource object that references your index image.
If you used the oc adm catalog mirror command to mirror your catalog to a target registry, you can use the generated catalogSource.yaml file in your manifests directory as a starting point.
1. Modify the following to your specifications and save it as a catalogSource.yaml file:

```yaml
apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: my-operator-catalog 1
  namespace: {namespace} 2
spec:
  sourceType: grpc
  grpcPodConfig:
    securityContextConfig: <security_mode> 3
  image: <registry>/<namespace>/{index-image}:{tag} 4
  displayName: My Operator Catalog
  publisher: <publisher_name> 5
  updateStrategy:
    registryPoll: 6
      interval: 30m
```

If you mirrored content to local files before uploading to a registry, remove any backslash (/) characters from the metadata.name field to avoid an "invalid resource name" error when you create the object.
If you want the catalog source to be available globally to users in all namespaces, specify the {namespace} namespace. Otherwise, you can specify a different namespace for the catalog to be scoped and available only for that namespace.
Specify the value of legacy or restricted. If the field is not set, the default value is legacy. In a future Red Hat OpenShift Container Platform release, it is planned that the default value will be restricted. If your catalog cannot run with restricted permissions, it is recommended that you manually set this field to legacy.
Specify your index image. If you specify a tag after the image name, for example :{tag}, the catalog source pod uses an image pull policy of Always, meaning the pod always pulls the image prior to starting the container. If you specify a digest, for example @sha256:<id>, the image pull policy is IfNotPresent, meaning the pod pulls the image only if it does not already exist on the node.
Specify your name or an organization name publishing the catalog.
Catalog sources can automatically check for new versions to keep up to date.
2. Use the file to create the CatalogSource object:

```terminal
$ oc apply -f catalogSource.yaml
```

2. Verify the following resources are created successfully.
1. Check the pods:

```terminal
$ oc get pods -n {namespace}
```

Example output

```terminal
NAME                                    READY   STATUS    RESTARTS  AGE
my-operator-catalog-6njx6               1/1     Running   0         28s
marketplace-operator-d9f549946-96sgr    1/1     Running   0         26h
```

2. Check the catalog source:

```terminal
$ oc get catalogsource -n {namespace}
```

Example output

```terminal
NAME                  DISPLAY               TYPE PUBLISHER  AGE
my-operator-catalog   My Operator Catalog   grpc            5s
```

3. Check the package manifest:

```terminal
$ oc get packagemanifest -n {namespace}
```

Example output

```terminal
NAME                          CATALOG               AGE
jaeger-product                My Operator Catalog   93s
```


You can now install the Operators from the OperatorHub page on your Red Hat OpenShift Container Platform web console.

* Accessing images for Operators from private registries
* Image template for custom catalog sources
* Image pull policy

# About Operator installation with OperatorHub

OperatorHub is a user interface for discovering Operators; it works in conjunction with Operator Lifecycle Manager (OLM), which installs and manages Operators on a cluster.

As a cluster administrator, you can install an Operator from OperatorHub by using the Red Hat OpenShift Container Platform

During installation, you must determine the following initial settings for the Operator:

Update Channel:: If an Operator is available through multiple channels, you can choose which channel you want to subscribe to. For example, to deploy from the stable channel, if available, select it from the list.
Approval Strategy:: You can choose automatic or manual updates.

If you choose automatic updates for an installed Operator, when a new version of that Operator is available in the selected channel, Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without human intervention.

If you select manual updates, when a newer version of an Operator is available, OLM creates an update request. As a
cluster administrator,
you must then manually approve that update request to have the Operator updated to the new version.

## Installing from OperatorHub using the web console

You can install and subscribe to an Operator from OperatorHub by using the Red Hat OpenShift Container Platform web console.

* Access to an Red Hat OpenShift Container Platform cluster using an account with

1. Navigate in the web console to the Operators → OperatorHub page.
2. Scroll or type a keyword into the Filter by keyword box to find the Operator you want. For example, type {filter-type} to find the {filter-operator} Operator.

You can also filter options by Infrastructure Features. For example, select Disconnected if you want to see Operators that work in disconnected environments, also known as restricted network environments.
3. Select the Operator to display additional information.

[NOTE]
----
Choosing a Community Operator warns that Red Hat does not certify Community Operators; you must acknowledge the warning before continuing.
----
4. Read the information about the Operator and click Install.
5. On the Install Operator page:
1. Select one of the following:
* All namespaces on the cluster (default) installs the Operator in the default openshift-operators namespace to watch and be made available to all namespaces in the cluster. This option is not always available.
* A specific namespace on the cluster allows you to choose a specific, single namespace in which to install the Operator. The Operator will only watch and be made available for use in this single namespace.
2. For clusters on cloud providers with token authentication enabled:
* If the cluster uses AWS STS (STS Mode in the web console), enter the Amazon Resource Name (ARN) of the AWS IAM role of your service account in the role ARN field.
![Entering the ARN]

To create the role's ARN, follow the procedure described in Preparing AWS account.
* If the cluster uses Microsoft Entra Workload ID (Workload Identity / Federated Identity Mode in the web console), add the client ID, tenant ID, and subscription ID in the appropriate field.
3. If more than one update channel is available, select an Update channel.
4. Select Automatic or Manual approval strategy, as described earlier.

[IMPORTANT]
----
If the web console shows that the cluster uses AWS STS or Microsoft Entra Workload ID, you must set Update approval to Manual.
Subscriptions with automatic update approvals are not recommended because there might be permission changes to make prior to updating. Subscriptions with manual update approvals ensure that administrators have the opportunity to verify the permissions of the later version and take any necessary steps prior to update.
----
6. Click Install to make the Operator available to the selected namespaces on this Red Hat OpenShift Container Platform cluster.
1. If you selected a Manual approval strategy, the upgrade status of the subscription remains Upgrading until you review and approve the install plan.

After approving on the Install Plan page, the subscription upgrade status moves to Up to date.
2. If you selected an Automatic approval strategy, the upgrade status should resolve to Up to date without intervention.
7. After the upgrade status of the subscription is Up to date, select Operators → Installed Operators to verify that the cluster service version (CSV) of the installed Operator eventually shows up. The Status should ultimately resolve to InstallSucceeded in the relevant namespace.

[NOTE]
----
For the All namespaces&#8230;&#8203; installation mode, the status resolves to InstallSucceeded in the openshift-operators namespace, but the status is Copied if you check in other namespaces.
----

If it does not:
1. Check the logs in any pods in the openshift-operators project (or other relevant namespace if A specific namespace&#8230;&#8203; installation mode was selected) on the Workloads → Pods page that are reporting issues to troubleshoot further.